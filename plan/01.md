# Mermaid Diagram Support Plan

This plan outlines the implementation of Mermaid diagram rendering for `md2docx`. It enables users to include Mermaid code blocks in their Markdown, which will be automatically rendered as PNG images and embedded into the final DOCX document.

## 1. Overview

The goal is to provide seamless Mermaid support. When the parser encounters:
~~~mermaid
graph TD
    A[Start] --> B{Is it working?}
    B -- Yes --> C[Great!]
    B -- No --> D[Debug]
~~~
It should render this diagram as an image in the DOCX output.

### Key Goals:
- High-quality rendering using headless Chrome (`chromiumoxide`).
- Fast performance through hash-based caching.
- Graceful fallbacks for environment without a browser.
- Configurable themes and scaling.

## 2. Architecture

The flow of a Mermaid block through the system:

1.  **Parsing**: `src/parser/markdown.rs` detects ` ```mermaid ` blocks and creates `Block::Mermaid { content }`.
2.  **Processing**: The `DocxBuilder` iterates through blocks. When it finds `Block::Mermaid`:
    a.  Generates a SHA256 hash of the content + config (theme, scale).
    b.  Checks the cache (`.md2docx-cache/mermaid/{hash}.png`).
    c.  If not cached, calls the Renderer.
3.  **Rendering**:
    -   **CLI**: Uses `chromiumoxide` to launch a headless browser, injects `mermaid.js`, and takes a screenshot of the rendered SVG.
    -   **Fallback**: Attempts to use `mmdc` (Mermaid CLI) if available on the path.
4.  **Embedding**: The resulting PNG is added to the DOCX's media directory and linked via a relationship, just like a standard image.

## 3. Implementation Phases

### Phase 1: Core Module Structure
- Create files: `mod.rs`, `renderer.rs`, `cache.rs`, `config.rs`, `cli.rs`, `wasm.rs`.
- Define the `MermaidConfig` struct.
- Define error types for Mermaid operations.

### Phase 2: CLI Rendering (chromiumoxide)
- Implement `render_with_chromium` in `cli.rs`.
- Setup a headless browser instance (singleton or per-session).
- HTML template for rendering Mermaid.
- Capture viewport as PNG.

### Phase 3: Caching System
- Implement `MermaidCache` in `cache.rs`.
- Ensure directory exists: `.md2docx-cache/mermaid/`.
- Simple file-based lookup.

### Phase 4: Integration
- Update `DocxBuilder` in `src/docx/builder.rs` to handle `Block::Mermaid`.
- Connect config from `md2docx.toml`.

### Phase 5: WASM & Fallbacks (Future)
- **WASM**: Call JavaScript's `mermaid.render()` and return base64.
- **Fallbacks**: Check for `mmdc` command if `chromiumoxide` fails or feature is disabled.

## 4. Module Structure (`src/mermaid/`)

-   `mod.rs`: Public API.
    ```rust
    pub fn render(content: &str, config: &MermaidConfig) -> Result<Vec<u8>, MermaidError>;
    ```
-   `config.rs`: `MermaidConfig` and `RendererType` enum.
-   `renderer.rs`: High-level orchestration, choosing between Chromium, mmdc, or WASM.
-   `cache.rs`: Logic for hashing content and managing the filesystem cache.
-   `cli.rs`: Headless Chrome integration (feature-gated `#[cfg(feature = "mermaid-cli")]`).
-   `wasm.rs`: JS interop (feature-gated `#[cfg(target_arch = "wasm32")]`).

## 5. Configuration (`md2docx.toml`)

```toml
[mermaid]
enabled = true
theme = "default"      # default, forest, dark, neutral
background = "white"   # or "transparent"
width = 800            # max width in pixels
scale = 2              # render scale for quality (2 = 2x DPI)
cache = true           # cache rendered diagrams
# CLI only:
renderer = "auto"      # "auto", "mmdc", "chromium"
```

## 6. Caching Strategy

-   **Location**: `.md2docx-cache/mermaid/` (relative to project root).
-   **Key**: `SHA256(content + theme + background + width + scale)`.
-   **Filename**: `{hash}.png`.
-   **Behavior**:
    -   If file exists, read and return bytes.
    -   If not, render, write to file, and return bytes.
-   **Cleanup**: (Optional) Add a subcommand to clear the cache.

## 7. Error Handling

-   If rendering fails (e.g., syntax error in Mermaid):
    -   Log a warning.
    -   Optionally render the source code as a fallback `CodeBlock`.
-   If Chromium is missing:
    -   Try `mmdc`.
    -   If both fail, show a helpful message about installing dependencies.

## 8. Integration Points

### `src/docx/builder.rs`
```rust
fn process_block(&mut self, block: Block) {
    match block {
        Block::Mermaid { content, id } => {
            let png_data = mermaid::render(&content, &self.config.mermaid)?;
            self.add_image_data(png_data, "Mermaid Diagram", id)?;
        }
        // ...
    }
}
```

## 9. Testing Strategy

-   **Unit Tests**:
    -   Cache key generation consistency.
    -   Configuration parsing.
-   **Integration Tests**:
    -   Render a simple flowchart and verify PNG header (`[0x89, 0x50, 0x4E, 0x47]`).
    -   Test multi-line Mermaid strings.
    -   Test with invalid Mermaid syntax (should return an Error, not panic).
-   **Manual Tests**:
    -   Verify visual quality in Word.
    -   Check that resizing works via `scale`.

## 10. Dependencies

-   `tokio`: Async runtime for `chromiumoxide`.
-   `chromiumoxide`: Headless Chrome control.
-   `sha2`: For hashing (need to add to `Cargo.toml`).
-   `hex`: For formatting hashes (need to add to `Cargo.toml`).
-   `directories`: For cross-platform cache paths (optional, can use local `.cache`).

## Implementation Checklist

- [ ] Create `src/mermaid/` files
- [ ] Implement `MermaidConfig` and TOML integration
- [ ] Implement `MermaidCache` with `sha2`
- [ ] Setup `chromiumoxide` renderer in `cli.rs`
- [ ] Create HTML/JS bridge for Mermaid rendering
- [ ] Integrate with `DocxBuilder`
- [ ] Add unit and integration tests
- [ ] Document in `README.md` or `AGENTS.md`
